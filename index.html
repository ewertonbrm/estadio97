<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>97 FM Podcast Player</title>
    
    <!-- Carrega a fonte Oswald do Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@300;400;600;700&display=swap" rel="stylesheet">
    
    <!-- Carrega Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define a fonte Oswald como padrão para toda a página */
        body {
            font-family: 'Oswald', sans-serif;
            /* Cor de fundo principal: Preto puro */
            background-color: #000000; 
        }
        /* Estilo para a barra de progresso do player */
        audio::-webkit-media-controls-enclosure {
            border-radius: 0.5rem; /* rounded-lg */
        }
        .episode-item {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        /* Efeito hover em tons de cinza escuro */
        .episode-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 15px -3px rgba(0, 0, 0, 0.6), 0 4px 6px -4px rgba(0, 0, 0, 0.3);
        }
        .loading-ring {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #f9fafb; /* gray-50 */
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <script>
        // Configuração do Tailwind (apenas para cores)
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        /* Define uma cor de destaque neutra/escura para bordas e botões */
                        'accent-dark': '#374151', /* gray-700 */
                    }
                }
            }
        }
    </script>
</head>
<body class="min-h-screen antialiased bg-black text-gray-100 flex flex-col">

    <div class="max-w-4xl mx-auto p-4 md:p-8 flex-grow w-full">

        <!-- Header e Título do Podcast -->
        <header id="podcast-header" class="bg-gray-900 shadow-xl rounded-xl p-6 mb-6">
            <h1 class="text-3xl font-extrabold text-white mb-2" id="podcast-title">Carregando Podcast...</h1>
            <p class="text-gray-400 text-sm" id="podcast-description">Buscando o feed RSS...</p>

            <!-- Loading Indicator (Anel de carregamento) -->
            <div id="loading-indicator" class="flex items-center justify-center mt-4">
                <div class="loading-ring"></div>
                <span class="ml-3 text-gray-300 font-medium">Buscando episódios...</span>
            </div>
        </header>

        <!-- Player de Áudio Principal -->
        <div id="main-player-container" class="sticky top-0 z-10 bg-gray-800 shadow-2xl rounded-xl p-4 mb-6 hidden">
            <p class="text-xs text-gray-300 font-bold uppercase mb-1">Tocando Agora:</p>
            <h2 id="current-episode-title" class="text-xl font-semibold mb-3 text-white">Nenhum episódio selecionado.</h2>
            <audio controls id="podcast-audio-player" class="w-full h-12 bg-gray-700 rounded-lg">
                Seu navegador não suporta o elemento de áudio.
            </audio>
        </div>

        <!-- Lista de Episódios -->
        <main id="episode-list-container">
            <h2 class="text-2xl font-bold text-gray-200 mb-4">Últimos Episódios</h2>
            <div id="episodes-list" class="space-y-4">
                <!-- Conteúdo dos episódios -->
            </div>
            
             <!-- Mensagem de Erro/Vazio -->
            <p id="error-message" class="hidden text-red-300 text-center p-6 bg-red-900 rounded-lg">
                Não foi possível carregar o feed. Verifique a URL do RSS ou o status do servidor proxy.
            </p>
        </main>

    </div>
    
    <!-- Rodapé Branco de Largura Total -->
    <footer class="w-full bg-white p-4 mt-8 shadow-inner">
        <div class="max-w-4xl mx-auto text-center text-gray-800 text-sm">
            Podcast Player | Exibindo os 7 episódios mais recentes.
        </div>
    </footer>


    <script>
        // URL do RSS e do Proxy
        const RSS_URL = "https://www.97fm.com.br/programas/podcasts.php?prg=25";
        // Usamos um proxy (allorigins.win) para evitar problemas de CORS
        const PROXY_URL = `https://api.allorigins.win/get?url=${encodeURIComponent(RSS_URL)}`;

        // Elementos do DOM
        const audioPlayer = document.getElementById('podcast-audio-player');
        const episodeListDiv = document.getElementById('episodes-list');
        const podcastTitleEl = document.getElementById('podcast-title');
        const podcastDescEl = document.getElementById('podcast-description');
        const currentEpisodeTitleEl = document.getElementById('current-episode-title');
        const playerContainer = document.getElementById('main-player-container');
        const loadingIndicator = document.getElementById('loading-indicator');
        const errorMessage = document.getElementById('error-message');
        
        // Variável global para armazenar o título do podcast para limpeza
        let globalPodcastTitle = '';

        /**
         * Converte uma data de string RSS (RFC 822) para um formato legível em português.
         * @param {string} dateString - A string de data do RSS.
         * @returns {string} Data formatada.
         */
        function formatDate(dateString) {
            try {
                // Tenta criar um objeto Date
                const date = new Date(dateString);
                // Verifica se é uma data válida
                if (isNaN(date)) {
                    return 'Data Indisponível';
                }
                // Formata a data para o padrão brasileiro
                return date.toLocaleDateString('pt-BR', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            } catch (e) {
                console.error("Erro ao formatar data:", e);
                return 'Data Indisponível';
            }
        }

        /**
         * Limpa o HTML da descrição de um episódio.
         * @param {string} html - A string contendo HTML.
         * @returns {string} Texto limpo.
         */
        function stripHtml(html) {
            // Cria um elemento temporário para converter HTML em texto puro
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = html;
            return tempDiv.textContent || "";
        }

        /**
         * Remove o título do podcast do início do título do episódio.
         * @param {string} episodeTitle - Título completo do episódio.
         * @returns {string} Título limpo.
         */
        function cleanTitle(episodeTitle) {
            if (!globalPodcastTitle || !episodeTitle) return episodeTitle;

            // Cria uma regex para remover o título do podcast e espaços/hífens adjacentes
            const regex = new RegExp(`^${globalPodcastTitle.trim()}[\\s\\-\\:\\.]*`, 'i');
            return episodeTitle.replace(regex, '').trim();
        }


        /**
         * Cria e injeta o HTML para um único item de episódio na lista.
         * @param {object} episode - Objeto com os detalhes do episódio.
         */
        function createEpisodeItem(episode) {
            const itemDiv = document.createElement('div');
            // Usando bg-gray-900 para maior contraste contra o fundo preto
            itemDiv.className = 'episode-item bg-gray-900 p-4 rounded-xl shadow-md border-l-4 border-gray-600 hover:border-gray-500 transition-all';
            itemDiv.dataset.audioUrl = episode.audioUrl;
            itemDiv.dataset.title = episode.title;
            
            const cleanedTitle = cleanTitle(episode.title);
            
            itemDiv.innerHTML = `
                <div class="flex items-center justify-between">
                    <div>
                        <!-- Título limpo e texto branco -->
                        <h3 class="text-lg font-semibold text-white">${cleanedTitle}</h3>
                        <!-- Data de Publicação (segunda linha), texto cinza-400 -->
                        <p class="text-sm text-gray-400 mt-1">Publicado em: ${formatDate(episode.pubDate)}</p>
                    </div>
                    <!-- Botão de Play em cinza escuro -->
                    <button class="flex-shrink-0 bg-gray-600 text-white p-2 rounded-full shadow-lg hover:bg-gray-500 transition duration-150 transform hover:scale-105" aria-label="Tocar episódio">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
                <!-- REMOVIDA A TERCEIRA LINHA (DESCRIÇÃO) -->
            `;

            // Adiciona o evento de clique para tocar o episódio
            itemDiv.addEventListener('click', () => {
                playEpisode(episode.audioUrl, cleanedTitle);
            });

            episodeListDiv.appendChild(itemDiv);
        }

        /**
         * Configura o player de áudio para tocar o episódio selecionado.
         * @param {string} url - URL do arquivo de áudio.
         * @param {string} title - Título do episódio.
         */
        function playEpisode(url, title) {
            if (!url) {
                console.error('Erro: URL do áudio não encontrada para este episódio.');
                // Usar um feedback na tela em vez de alert()
                currentEpisodeTitleEl.textContent = `Erro ao carregar: ${title}. URL de áudio indisponível.`;
                playerContainer.classList.remove('hidden'); 
                return;
            }
            // Exibe o player se estiver oculto
            playerContainer.classList.remove('hidden'); 
            
            // Atualiza o título do episódio atual
            currentEpisodeTitleEl.textContent = title;
            
            // Define a fonte do áudio e inicia a reprodução
            audioPlayer.src = url;
            audioPlayer.load();
            audioPlayer.play().catch(error => {
                console.warn("Reprodução automática falhou, o usuário precisará clicar em play:", error);
                // Exibe uma mensagem de feedback no player
                currentEpisodeTitleEl.textContent = `${title} (Clique no Play)`;
            });

            // Rolagem suave para o player
            playerContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        /**
         * Busca e processa o feed RSS.
         */
        async function fetchAndParseRSS() {
            loadingIndicator.classList.remove('hidden');
            errorMessage.classList.add('hidden');
            episodeListDiv.innerHTML = ''; // Limpa a lista antes de carregar
            
            try {
                // 1. Busca o conteúdo usando o proxy
                const response = await fetch(PROXY_URL);
                if (!response.ok) {
                    throw new Error(`Erro de rede: ${response.statusText}`);
                }
                const data = await response.json();
                
                const rssContent = data.contents;
                
                // 2. Analisa o XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(rssContent, "text/xml");

                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    throw new Error("Erro ao analisar o XML do feed.");
                }

                const channel = xmlDoc.querySelector('channel');

                // 3. Extrai informações do Podcast (Canal)
                const podcastTitle = channel.querySelector('title')?.textContent || 'Podcast Desconhecido';
                globalPodcastTitle = podcastTitle; // Armazena globalmente
                const podcastDescription = stripHtml(channel.querySelector('description')?.textContent || 'Descrição Indisponível');

                podcastTitleEl.textContent = podcastTitle;
                podcastDescEl.textContent = podcastDescription.substring(0, 300) + (podcastDescription.length > 300 ? '...' : '');

                // 4. Extrai os Episódios
                const items = channel.querySelectorAll('item');
                const episodes = [];

                items.forEach(item => {
                    const enclosure = item.querySelector('enclosure');
                    
                    if (enclosure) {
                        episodes.push({
                            title: item.querySelector('title')?.textContent || 'Título Indisponível',
                            pubDate: item.querySelector('pubDate')?.textContent || new Date().toISOString(), // Data restaurada
                            audioUrl: enclosure.getAttribute('url'),
                        });
                    }
                });

                // 5. Renderiza os episódios, limitando a 7
                const limitedEpisodes = episodes.slice(0, 7);
                
                if (limitedEpisodes.length > 0) {
                    limitedEpisodes.forEach(createEpisodeItem);
                } else {
                     episodeListDiv.innerHTML = '<p class="text-center text-gray-400 p-6 bg-gray-700 rounded-lg">Nenhum episódio encontrado neste feed.</p>';
                }

            } catch (error) {
                console.error("Ocorreu um erro ao buscar ou processar o feed:", error);
                podcastTitleEl.textContent = "Erro de Carregamento";
                podcastDescEl.textContent = "Houve um problema ao buscar os dados do podcast.";
                errorMessage.classList.remove('hidden');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }

        // Inicia o carregamento quando a página terminar de carregar
        window.onload = fetchAndParseRSS;

    </script>
</body>
</html>

