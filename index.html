<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Estádio 97</title>
    <!-- Carrega Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Define a fonte Inter como padrão */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
        }
        /* Estilo para a barra de progresso do player */
        audio::-webkit-media-controls-enclosure {
            border-radius: 0.5rem; /* rounded-lg */
        }
        .episode-item {
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .episode-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
        .loading-ring {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #fff;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        'primary-97': '#1E40AF', /* Blue-800 */
                        'secondary-97': '#D1D5DB', /* Gray-300 */
                    }
                }
            }
        }
    </script>
</head>
<body class="min-h-screen antialiased text-gray-800">

    <div class="max-w-4xl mx-auto p-4 md:p-8">

        <!-- Header e Título do Podcast -->
        <header id="podcast-header" class="bg-white shadow-lg rounded-xl p-6 mb-6">
            <h1 class="text-3xl font-extrabold text-primary-97 mb-2" id="podcast-title">Carregando Podcast...</h1>
            <p class="text-gray-500 text-sm" id="podcast-description">Buscando o feed RSS...</p>

            <!-- Loading Indicator (Anel de carregamento) -->
            <div id="loading-indicator" class="flex items-center justify-center mt-4">
                <div class="loading-ring border-primary-97 border-t-primary-97"></div>
                <span class="ml-3 text-primary-97 font-medium">Buscando episódios...</span>
            </div>
        </header>

        <!-- Player de Áudio Principal -->
        <div id="main-player-container" class="sticky top-0 z-10 bg-white shadow-2xl rounded-xl p-4 mb-6 hidden">
            <p class="text-xs text-primary-97 font-bold uppercase mb-1">Tocando Agora:</p>
            <h2 id="current-episode-title" class="text-xl font-semibold mb-3">Nenhum episódio selecionado.</h2>
            <audio controls id="podcast-audio-player" class="w-full h-12 bg-gray-100 rounded-lg">
                Seu navegador não suporta o elemento de áudio.
            </audio>
        </div>

        <!-- Lista de Episódios -->
        <main id="episode-list-container">
            <!-- Os episódios serão injetados aqui pelo JavaScript -->
            <h2 class="text-2xl font-bold text-gray-700 mb-4">Últimos Episódios</h2>
            <div id="episodes-list" class="space-y-4">
                <!-- Conteúdo dos episódios -->
            </div>
            
             <!-- Mensagem de Erro/Vazio -->
            <p id="error-message" class="hidden text-red-500 text-center p-6 bg-red-100 rounded-lg">
                Não foi possível carregar o feed. Verifique a URL do RSS ou o status do servidor proxy.
            </p>
        </main>

    </div>

    <script>
        // URL do RSS e do Proxy
        const RSS_URL = "https://www.97fm.com.br/programas/podcasts.php?prg=25";
        // Usamos um proxy (allorigins.win) para evitar problemas de CORS
        const PROXY_URL = `https://api.allorigins.win/get?url=${encodeURIComponent(RSS_URL)}`;

        // Elementos do DOM
        const audioPlayer = document.getElementById('podcast-audio-player');
        const episodeListDiv = document.getElementById('episodes-list');
        const podcastTitleEl = document.getElementById('podcast-title');
        const podcastDescEl = document.getElementById('podcast-description');
        const currentEpisodeTitleEl = document.getElementById('current-episode-title');
        const playerContainer = document.getElementById('main-player-container');
        const loadingIndicator = document.getElementById('loading-indicator');
        const errorMessage = document.getElementById('error-message');

        /**
         * Converte uma data de string RSS (RFC 822) para um formato legível em português.
         * @param {string} dateString - A string de data do RSS.
         * @returns {string} Data formatada.
         */
        function formatDate(dateString) {
            try {
                // Tenta criar um objeto Date
                const date = new Date(dateString);
                // Verifica se é uma data válida
                if (isNaN(date)) {
                    return 'Data Indisponível';
                }
                // Formata a data para o padrão brasileiro
                return date.toLocaleDateString('pt-BR', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
            } catch (e) {
                console.error("Erro ao formatar data:", e);
                return 'Data Indisponível';
            }
        }

        /**
         * Limpa o HTML da descrição de um episódio.
         * @param {string} html - A string contendo HTML.
         * @returns {string} Texto limpo.
         */
        function stripHtml(html) {
            const doc = new DOMParser().parseFromString(html, 'text/html');
            return doc.body.textContent || "";
        }

        /**
         * Cria e injeta o HTML para um único item de episódio na lista.
         * @param {object} episode - Objeto com os detalhes do episódio.
         */
        function createEpisodeItem(episode) {
            const itemDiv = document.createElement('div');
            itemDiv.className = 'episode-item bg-white p-4 rounded-xl shadow-md border-l-4 border-primary-97/70 hover:border-primary-97 transition-all';
            itemDiv.dataset.audioUrl = episode.audioUrl;
            itemDiv.dataset.title = episode.title;
            
            const cleanDescription = stripHtml(episode.description).substring(0, 150) + '...';

            itemDiv.innerHTML = `
                <div class="flex items-center justify-between">
                    <div>
                        <h3 class="text-lg font-semibold text-gray-900">${episode.title}</h3>
                        <p class="text-sm text-gray-500 mt-1">Publicado em: ${formatDate(episode.pubDate)}</p>
                    </div>
                    <button class="flex-shrink-0 bg-primary-97 text-white p-2 rounded-full shadow-lg hover:bg-primary-97/80 transition duration-150 transform hover:scale-105" aria-label="Tocar episódio">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zM9.555 7.168A1 1 0 008 8v4a1 1 0 001.555.832l3-2a1 1 0 000-1.664l-3-2z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
                <p class="text-sm text-gray-600 mt-3">${cleanDescription}</p>
            `;

            // Adiciona o evento de clique para tocar o episódio
            itemDiv.addEventListener('click', () => {
                playEpisode(episode.audioUrl, episode.title);
            });

            episodeListDiv.appendChild(itemDiv);
        }

        /**
         * Configura o player de áudio para tocar o episódio selecionado.
         * @param {string} url - URL do arquivo de áudio.
         * @param {string} title - Título do episódio.
         */
        function playEpisode(url, title) {
            if (!url) {
                alert('Erro: URL do áudio não encontrada para este episódio.');
                return;
            }
            // Exibe o player se estiver oculto
            playerContainer.classList.remove('hidden'); 
            
            // Atualiza o título do episódio atual
            currentEpisodeTitleEl.textContent = title;
            
            // Define a fonte do áudio e inicia a reprodução
            audioPlayer.src = url;
            audioPlayer.load();
            audioPlayer.play().catch(error => {
                // Captura erro se o navegador impedir a reprodução automática
                console.warn("Reprodução automática falhou, o usuário precisará clicar em play:", error);
                // Exibe uma mensagem de feedback no player
                currentEpisodeTitleEl.textContent = `${title} (Clique no Play)`;
            });

            // Rolagem suave para o player
            playerContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        /**
         * Busca e processa o feed RSS.
         */
        async function fetchAndParseRSS() {
            loadingIndicator.classList.remove('hidden');
            errorMessage.classList.add('hidden');
            
            try {
                // 1. Busca o conteúdo usando o proxy
                const response = await fetch(PROXY_URL);
                if (!response.ok) {
                    throw new Error(`Erro de rede: ${response.statusText}`);
                }
                const data = await response.json();
                
                // O conteúdo do RSS estará dentro do campo 'contents'
                const rssContent = data.contents;
                
                // 2. Analisa o XML
                const parser = new DOMParser();
                const xmlDoc = parser.parseFromString(rssContent, "text/xml");

                // Verifica se houve erro na análise do XML
                const parseError = xmlDoc.querySelector('parsererror');
                if (parseError) {
                    throw new Error("Erro ao analisar o XML do feed.");
                }

                const channel = xmlDoc.querySelector('channel');

                // 3. Extrai informações do Podcast (Canal)
                const podcastTitle = channel.querySelector('title').textContent;
                const podcastDescription = stripHtml(channel.querySelector('description').textContent);

                podcastTitleEl.textContent = podcastTitle;
                podcastDescEl.textContent = podcastDescription.substring(0, 300) + '...'; // Limita descrição

                // 4. Extrai os Episódios
                const items = channel.querySelectorAll('item');
                const episodes = [];

                items.forEach(item => {
                    const enclosure = item.querySelector('enclosure');
                    
                    // Garante que o item tenha um áudio associado
                    if (enclosure) {
                        episodes.push({
                            title: item.querySelector('title')?.textContent || 'Título Indisponível',
                            description: item.querySelector('description')?.textContent || 'Descrição Indisponível',
                            pubDate: item.querySelector('pubDate')?.textContent || new Date().toISOString(),
                            audioUrl: enclosure.getAttribute('url')
                        });
                    }
                });

                // 5. Renderiza os episódios
                if (episodes.length > 0) {
                    episodeListDiv.innerHTML = ''; // Limpa o indicador de "carregando"
                    episodes.forEach(createEpisodeItem);
                    // Toca o primeiro episódio automaticamente (opcional)
                    // playEpisode(episodes[0].audioUrl, episodes[0].title);
                } else {
                     episodeListDiv.innerHTML = '<p class="text-center text-gray-500 p-6 bg-gray-50 rounded-lg">Nenhum episódio encontrado neste feed.</p>';
                }

            } catch (error) {
                console.error("Ocorreu um erro ao buscar ou processar o feed:", error);
                podcastTitleEl.textContent = "Erro de Carregamento";
                podcastDescEl.textContent = "Houve um problema ao buscar os dados do podcast.";
                errorMessage.classList.remove('hidden');
            } finally {
                loadingIndicator.classList.add('hidden');
            }
        }

        // Inicia o carregamento quando a página terminar de carregar
        window.onload = fetchAndParseRSS;

    </script>
</body>
</html>
